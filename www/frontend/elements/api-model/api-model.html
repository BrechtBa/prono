
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../bower_components/iron-localstorage/iron-localstorage.html">

<dom-module id="api-model">
    <template>

        <style>
        </style>

        <iron-localstorage name="[[url]]" value="{{cacheModel}}" on-iron-localstorage-load="_loadFromCache" on-iron-localstorage-load-empty="_initializeData" auto-save-disabled="[[!useLocalStorage]]"></iron-localstorage>

        <iron-ajax id="post"   method="POST"   content-type="application/json" handle-as="json" last-response="{{postResponse}}"   on-response="handlePostResponse"   on-error="handlePostError" debounce-duration="300"></iron-ajax>
        <iron-ajax id="get"    method="GET"    content-type="application/json" handle-as="json" last-response="{{getResponse}}"    on-response="handleGetResponse"    on-error="handleGetError" debounce-duration="300"></iron-ajax>
        <iron-ajax id="put"    method="PUT"    content-type="application/json" handle-as="json" last-response="{{putResponse}}"    on-response="handlePutResponse"    on-error="handlePutError" debounce-duration="300"></iron-ajax>
        <iron-ajax id="delete" method="DELETE" content-type="application/json" handle-as="json" last-response="{{deleteResponse}}" on-response="handleDeleteResponse" on-error="handleDeleteError" debounce-duration="300"></iron-ajax>
        
        <iron-ajax id="lastUpdateAjax" method="GET" url="[[lastUpdateUrl]]" content-type="application/json" handle-as="json" last-response="{{lastUpdateResponse}}" on-response="handleLastUpdateResponse" debounce-duration="300"></iron-ajax>


    </template>

    <script>
        Polymer({
            is: 'api-model',
            properties: {
                /**
                 * the data
                 */
                model: {
                    type: 'Array',
                    notify: true
                },
                /**
                 * api url, is also used as the local storage value key
                 */
                url: {
                    type: 'String'
                },
                /**
                 * token used for api authentication
                 * when the token changes a check is performed to ensure it is a JWT.
                 * if the check fails, the model is replaced by an empty array
                 */
                token: {
                    type: 'String',
                    value: '',
                    observer: 'tokenChanged'
                },
                /**
                 * when true a get request completely replaces the model
                 */
                overwrite: {
                    type: 'Boolean',
                    value: false,
                },
                /**
                 * cache the data or not
                 */
                useLocalStorage: {
                    type: 'Boolean',
                    value: true,
                },
                /**
                 * polling interval in seconds
                 */
                pollingInterval: {
                    type: 'Number',
                    value: -1,
                    observer: 'pollingIntervalChanged'
                },
                /**
                 * an api url which supplies a utc timestamp of when the last
                 * update to the data has occured. This is usefull when the
                 * dataset itself is large and polling it with a short interval
                 * would induce a lot of traffic. Instead the lastUpdateUrl is
                 * checked, which is not a lot of data transfer, and only if the
                 * returned date is larger than the stored lastUpdate, the
                 * actual data is reloaded.
                 *
                 * the response should be JSON data with a "date" field which
                 * contains a unix timestamp in seconds
                 */
                lastUpdateUrl: {
                    type: 'String',
                    value: ''
                }
            },
            listeners: {
            },
            observers: [
            ],
            ready: function(){
                this.lastUpdate = 0;
            },
            tokenChanged: function(token){
                try{
                    var parts = token.split('.');
                    this.header = JSON.parse(atob(parts[0]));
                    this.payload = JSON.parse(atob(parts[1]));

                    // set headers
                    this.$.get.headers['Authorization']    = 'JWT '+this.token;
                    this.$.post.headers['Authorization']   = 'JWT '+this.token;
                    this.$.put.headers['Authorization']    = 'JWT '+this.token;
                    this.$.delete.headers['Authorization'] = 'JWT '+this.token;
                    this.$.lastUpdateAjax.headers['Authorization'] = 'JWT '+this.token;
                }
                catch(e){
                    // the token is not a JWT
                    //this.model['data'] = [];

                    this.$.get.headers['Authorization'] = '';
                    this.$.post.headers['Authorization'] = '';
                    this.$.put.headers['Authorization'] = '';
                    this.$.delete.headers['Authorization'] = '';
                    this.$.lastUpdateAjax.headers['Authorization'] = '';

                    this.header = {};
                    this.payload = {};
                    this.stopIntervalPolling();

                    if(typeof this.model != 'undefined' && this.model.length >0){
                        console.log('set model '+ this.name +' to []');
                        this.model = [];
                        this.fire('change');
                    }
                }
            },
            pollingIntervalChanged: function(pollingInterval){
                this.stopIntervalPolling();
                this.startIntervalPolling();

            },
            post: function(data){
                this.$.post.url = this.url;

                this.$.post.body = JSON.stringify(data);
                console.log('post ' + this.$.post.body + ' to ' + this.$.post.url);
                this.$.post.generateRequest();
            },
            get: function(selector){
                if(typeof selector == 'undefined'){
                    this.$.get.url = this.url;
                }
                else{
                    this.$.get.url = this.url + selector;
                };
                console.log('get ' + this.$.get.url);

                this.$.get.generateRequest();
                
                this.startIntervalPolling();
            },
            put: function(selector,data){
                this.$.put.url = this.url + selector;

                this.$.put.body = JSON.stringify(data);
                console.log('put ' + JSON.stringify(data) + ' in ' + this.$.put.url);
                this.$.put.generateRequest();
            },
            delete: function(selector){
                this.$.delete.url = this.url + selector;
                this.$.delete.generateRequest();
            },
            handlePostResponse: function(e,request){
                this.updateModel([e.detail.response]);
            },
            handleGetResponse: function(e,request){
                this.lastUpdate = Math.floor( new Date().getTime()/1000 );
                this.updateModel(e.detail.response);
            },
            handlePutResponse: function(e,request){
                this.updateModel([e.detail.response]);
            },
            handleDeleteResponse: function(e,request){
                console.log(e);
                console.log(request);
                // completely reload the model
                // this is overkill, but the easiest way
                this.model = [];
                this.get();
            },
            updateModel: function(data){
                var that = this;
                var tempmodel = data;

                if(!this.overwrite){
                    // create a temporary model with the same values
                    tempmodel = []
                    if( typeof this.model != 'undefined' ){
                       tempmodel = JSON.parse(JSON.stringify(this.model))
                    }
                    data.forEach(function(item){

                        // check if the item id is in model data
                        var index = that._indexOfId(tempmodel,item.id);

                        if(index == -1){
                          tempmodel.push(item);
                        }
                        else{
                         for(var k in item) tempmodel[index][k] = item[k];
                        }
                    });
                }

                console.log('loaded ' + this.$.get.url);

                this.model = tempmodel;
                this.cacheModel = tempmodel;
                this.fire('change');
            },
            handlePostError: function(){
            },
            handleGetError: function(){
            },
            handlePutError: function(){
            },
            handleDeleteError: function(){
            },
            startIntervalPolling: function(){
                if(typeof this.updateCheckInterval == 'undefined' || this.updateCheckInterval == null){
                    var that = this;

                    if(this.pollingInterval > 0.01){

                        if(this.lastUpdateUrl == ''){
                            this.get()
                        }
                        else{
                            this.updateCheckInterval = window.setInterval(function(){
                                that.$.lastUpdateAjax.generateRequest();
                            }, that.pollingInterval*1000);
                        }
                    }
                }
            },
            stopIntervalPolling: function(){
                clearInterval(this.updateCheckInterval);
            },
            handleLastUpdateResponse: function(e,request){
                console.log('checked if update was required for '+this.url);
                if(this.lastUpdate < e.detail.response['date']){
                    this.get();
                }
            },
            _indexOfId: function(array,id){
                var index = -1;
                array.forEach(function(item,ind){
                    if(item.id == id){
                        index = ind;
                    }
                });
                return index;
            },
            _initializeData: function(e){
                this.model = [];
            },
            _loadFromCache: function(e){
                this.model = this.cacheModel;
                console.log('loaded ' + this.$.get.url + ' from cache');
                this.fire('change');
            },
            _clearCache: function(){
                this.cacheModel = null;
            }
        });
    </script>

</dom-module>
